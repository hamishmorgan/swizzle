//! # Swizzle
//!
//! Macro for generating swizzle functions on structs.
//!
//! The `swizzle!` macro automatically generates functions that allow you to create new instances
//! of a struct with field values rearranged according to any combination of the original fields.
//! This is particularly useful for mathematical operations, graphics programming, and data manipulation.
//!
//! ## What is Swizzling?
//!
//! Swizzling is a technique commonly used in graphics programming where you can access and
//! reorder vector components in any combination. For example, with a 3D vector `(x, y, z)`,
//! you might want to create a new vector with values `(y, x, z)` or `(x, x, x)`.
//!
//! ## Quick Start
//!
//! ```rust
//! use swizzle::swizzle;
//!
//! struct Vec2 {
//!     x: f32,
//!     y: f32,
//! }
//!
//! impl Vec2 {
//!     swizzle!(Vec2 { x, y });
//! }
//!
//! let v = Vec2 { x: 1.0, y: 2.0 };
//! let v_swapped = v.yx();  // Vec2 { x: 2.0, y: 1.0 }
//! let v_repeated = v.xx(); // Vec2 { x: 1.0, y: 1.0 }
//! ```
//! ## Use Cases
//!
//! - **Graphics Programming**: Swizzling vector components (xy, yx, xyz, etc.)
//! - **Data Manipulation**: Reordering struct fields for different data views
//! - **Mathematical Operations**: Creating variations of mathematical objects
//! - **API Design**: Providing convenient access patterns for struct data
//!
//! ## Examples
//!
//! ### 2D Vector
//! ```rust
//! use swizzle::swizzle;
//!
//! struct Vec2 {
//!     x: f32,
//!     y: f32,
//! }
//!
//! impl Vec2 {
//!     swizzle!(Vec2 { x, y });
//! }
//!
//! let v = Vec2 { x: 1.0, y: 2.0 };
//! assert_eq!(v.xx().x, 1.0);
//! assert_eq!(v.xx().y, 1.0);
//! assert_eq!(v.yy().x, 2.0);
//! assert_eq!(v.yy().y, 2.0);
//! assert_eq!(v.xy().x, 1.0);
//! assert_eq!(v.xy().y, 2.0);
//! assert_eq!(v.yx().x, 2.0);
//! assert_eq!(v.yx().y, 1.0);
//! ```
//!
//! ### 3D Vector
//! ```rust
//! use swizzle::swizzle;
//!
//! struct Vec3 {
//!     x: f32,
//!     y: f32,
//!     z: f32,
//! }
//!
//! impl Vec3 {
//!     swizzle!(Vec3 { x, y, z });
//! }
//!
//! let v = Vec3 { x: 1.0, y: 2.0, z: 3.0 };
//! let v_xy = v.xyy();      // Vec3 { x: 1.0, y: 2.0, z: 2.0 }
//! let v_reverse = v.zyx(); // Vec3 { x: 3.0, y: 2.0, z: 1.0 }
//! ```
//!
//! ### Color with Alpha
//! ```rust
//! use swizzle::swizzle;
//!
//! struct Color {
//!     r: u8,
//!     g: u8,
//!     b: u8,
//!     a: u8,
//! }
//!
//! impl Color {
//!     swizzle!(Color { r, g, b, a });
//! }
//!
//! let c = Color { r: 255, g: 128, b: 64, a: 255 };
//! let c_bgr = c.bgrb();    // Color { r: 64, g: 128, b: 255, a: 64 }
//! let c_grayscale = c.rrrr(); // Color { r: 255, g: 255, b: 255, a: 255 }
//! ```
//!
//! ### Cross-Type Swizzling
//! ```rust
//! use swizzle::swizzle;
//!
//! struct Vec2 {
//!     x: f32,
//!     y: f32,
//! }
//!
//! struct Vec3 {
//!     x: f32,
//!     y: f32,
//!     z: f32,
//! }
//!
//! impl Vec2 {
//!     // Create Vec3 from Vec2 by repeating components
//!     swizzle!(Vec3 { x: (x, y), y: (x, y), z: (x, y) });
//! }
//!
//! impl Vec3 {
//!     // Create Vec2 from Vec3 by selecting components
//!     swizzle!(Vec2 { x: (x, y, z), y: (x, y, z) });
//! }
//!
//! let v2 = Vec2 { x: 1.0, y: 2.0 };
//! let v3 = v2.xyx(); // Vec3 { x: 1.0, y: 2.0, z: 1.0 }
//!
//! let v3_orig = Vec3 { x: 1.0, y: 2.0, z: 3.0 };
//! let v2_proj = v3_orig.xy(); // Vec2 { x: 1.0, y: 2.0 }
//! ```
//!
//! ## Performance Considerations
//!
//! - All generated functions are `#[inline]` for optimal performance
//! - Functions are marked as `#[must_use]` to prevent accidental discarding of results
//! - All generated functions are `const fn` for use in const contexts
//! - The macro generates `n^n` functions for a struct with `n` fields
//! - For large numbers of fields, consider the compilation time impact
//!
//! ## Limitations
//!
//! - Field names must be valid Rust identifiers
//! - All fields must be of types that can be copied
//! - The macro generates a lot of functions for structs with many fields
//! - Field order in the struct definition matters for the generated function names
//!
//! ## How It Works
//!
//! The macro generates all possible combinations of field values. For a struct with `n` fields, it creates `n^n` different swizzle functions. Each function returns a new instance of the struct with the field values arranged according to the function name.
//!
//! **Important**: The function names generated by the macro have exactly the same length as the number of fields in the struct. For example:
//! - A 2-field struct generates 2-character function names: `aa()`, `ab()`, `ba()`, `bb()`
//! - A 3-field struct generates 3-character function names: `aaa()`, `abc()`, `zyx()`, etc.
//! - A 4-field struct generates 4-character function names: `aaaa()`, `abcd()`, `dcba()`, etc.
//!
//! ### Generated Functions
//!
//! For each possible combination of field names, the macro generates a function named after that combination:
//!
//! - `aaa()` → returns struct with all fields set to the value of `a`
//! - `abc()` → returns struct with fields set to `a`, `b`, `c` respectively
//! - `cba()` → returns struct with fields set to `c`, `b`, `a` respectively
//!
//! ### Advanced Usage
//!
//! The macro supports cross-type swizzling where you can create instances of different structs:
//!
//! ```rust
//! use swizzle::swizzle;
//!
//! struct SourceStruct {
//!     src1: f32,
//!     src2: f32,
//! }
//!
//! struct TargetStruct {
//!     field1: f32,
//!     field2: f32,
//! }
//!
//! impl SourceStruct {
//!     swizzle!(TargetStruct { field1: (src1, src2), field2: (src1, src2) });
//! }
//!
//! let src = SourceStruct { src1: 1.0, src2: 2.0 };
//! let target = src.src1src2(); // TargetStruct { field1: 1.0, field2: 2.0 }
//! ```
//!
//! This creates functions that return `TargetStruct` with values from the source struct's fields.
//!
//! ## Dependencies
//!
//! This crate depends on the `paste` crate for hygienic macro expansion.
//!
//! ## License
//!
//! This project is licensed under the MIT License.

mod swizzle;
